<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Web Flash Tool</title>
</head>
<body>
    <h1>ESP32 Web Flash Tool</h1>
    
    <div>
        <h2>Flash</h2>
        
        <div>
            <label for="fileInput">Select .bin file:</label>
            <input type="file" id="fileInput" accept=".bin" />
        </div>
        
        <div>
            <label for="addressSelect">Memory Address:</label>
            <select id="addressSelect">
                <option value="0x1000">0x1000 - Bootloader</option>
                <option value="0x8000">0x8000 - Partition Table</option>
                <option value="0x10000">0x10000 - Application</option>
                <option value="0x20000">0x20000 - OTA Data</option>
                <option value="0x30000">0x30000 - NVS</option>
                <option value="0x40000">0x40000 - SPIFFS</option>
                <option value="0x50000">0x50000 - LittleFS</option>
                <option value="custom">Custom Address</option>
            </select>
        </div>
        
        <div id="customAddressDiv" style="display: none;">
            <label for="customAddress">Custom Address (hex):</label>
            <input type="text" id="customAddress" placeholder="0x10000" />
        </div>
        
        
        <div>
            <button id="connectButton">Connect</button>
            <button id="flashButton" disabled>Flash</button>
        </div>
        
        <div id="status"></div>
    </div>

    <script type="module">
        import { ESPLoader, Transport } from './esptools.js';
        
        let espLoader = null;
        let transport = null;
        let serialPort = null;
        
        const flashButton = document.getElementById('flashButton');
        const connectButton = document.getElementById('connectButton');
        
        document.getElementById('addressSelect').addEventListener('change', function() {
            const customDiv = document.getElementById('customAddressDiv');
            if (this.value === 'custom') {
                customDiv.style.display = 'block';
            } else {
                customDiv.style.display = 'none';
            }
        });
        
        connectButton.addEventListener('click', connectESP32);
        flashButton.addEventListener('click', flashESP32);
        
        async function connectESP32() {
            try {
                console.log('Connecting to ESP32...');
                updateStatus('Connecting to ESP32...');
                
                const port = await navigator.serial.requestPort();
                serialPort = port;
                
                transport = new Transport(port);
                console.log('Transport created:', transport);
                
                
                console.log('Creating ESPLoader:', transport);
                const loaderOptions = {
                    transport: transport,
                    baudrate: 115200,
                    debugLogging: true
                };
                espLoader = new ESPLoader(loaderOptions);
                console.log('ESPLoader:', espLoader);
                
                console.log('Connecting...');
                try {
                    await espLoader.main(); // Does auto-reset automatically
                } catch (firstError) {
                    // If connection fails, the board might have been reset into download mode
                    // Wait a moment and retry
                    console.log('First connection attempt failed, board may be entering download mode...');
                    console.log('Error:', firstError);
                    updateStatus('Board entering download mode, retrying connection...');
                    
                    // Wait for board to enter download mode
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Retry connection
                    console.log('Retrying connection...');
                    await espLoader.main();
                }
                
                console.log('Connected to ESP32');
                updateStatus('Connected to ESP32');
                
                flashButton.disabled = false;
                connectButton.disabled = true;
                
            } catch (error) {
                console.error('Connection failed:', error);
                updateStatus('Connection failed: ' + error.message);
                
                flashButton.disabled = true;
                connectButton.disabled = false;
            }
        }
        
        function readFileData(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = (err) => reject(err);
                reader.readAsBinaryString(file);
            });
        }
        
        async function flashESP32() {
            if (!espLoader) {
                updateStatus('No ESP32 connected');
                return;
            }
            
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                updateStatus('Select .bin file');
                return;
            }

            flashButton.disabled = true;

            try {
                console.log('Starting flashing...');
                updateStatus('Starting flashing...');
                
                // Address
                let address;
                const addressSelect = document.getElementById('addressSelect');
                if (addressSelect.value === 'custom') {
                    const customAddress = document.getElementById('customAddress').value;
                    if (!customAddress) {
                        updateStatus('Please enter custom address');
                        return;
                    }
                    address = parseInt(customAddress, 16);
                } else {
                    address = parseInt(addressSelect.value, 16);
                }
                
                console.log('Flash address:', '0x' + address.toString(16));
                
                const fileData = await readFileData(file);
                console.log('File size:', fileData.length, 'bytes');
                
                const flashOptions = {
                    fileArray: [{ data: fileData, address: address }],
                    eraseAll: false,
                    compress: true, 
                    flashSize: "keep",
                    flashMode: "keep",
                    flashFreq: "keep",
                    reportProgress: (fileIndex, written, total) => {
                        const progress = (written / total) * 100;
                        updateStatus(`Flashing... ${Math.round(progress)}%`);
                    }
                };
                
                updateStatus('Flashing...');
                await espLoader.writeFlash(flashOptions);
                
                console.log('Flash completed successfully');
                updateStatus('Flash completed successfully');
                
                // Reset after flashing
                console.log('Resetting ESP32...');
                updateStatus('Resetting ESP32...');
                
                // Use hard_reset to exit download mode and boot normally
                await espLoader.after("hard_reset");
                
                // Additional reset sequence to ensure board exits download mode
                // Some boards need DTR/RTS to be toggled to properly exit download mode
                if (serialPort && serialPort.setSignals) {
                    try {
                        // Ensure DTR and RTS are released (high) to boot normally
                        await serialPort.setSignals({ 
                            dataTerminalReady: true,
                            requestToSend: true 
                        });
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                        // Brief pulse to ensure clean reset
                        await serialPort.setSignals({ 
                            dataTerminalReady: false,
                            requestToSend: false 
                        });
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                        // Release to boot
                        await serialPort.setSignals({ 
                            dataTerminalReady: true,
                            requestToSend: true 
                        });
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (signalError) {
                        console.log('Could not set signals directly, using default reset:', signalError);
                    }
                }
                
                updateStatus('Flash complete - Board reset');
                
            } catch (error) {
                console.error('Flash failed:', error);
                updateStatus('Flash failed: ' + error.message);
            } finally {
                flashButton.disabled = false;
            }
        }
        
        function updateStatus(message) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            console.log('Status:', message);
        }
        
        if (!navigator.serial) {
            updateStatus('Web Serial API not supported. Please use Chrome/Edge browser.');
        }
    </script>
</body>
</html>